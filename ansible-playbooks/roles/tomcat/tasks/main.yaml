---
- hosts: all
  become: yes
  vars:
    tomcat_install_dir: "{{ tomcat_install_dir | default('/opt/tomcat') }}"
    tomcat_user: "{{ tomcat_user | default('tomcat') }}"
    tomcat_group: "{{ tomcat_group | default('tomcat') }}"
    tomcat_manager_dir: "{{ tomcat_install_dir }}/webapps/manager"
    tomcat_host_manager_dir: "{{ tomcat_install_dir }}/webapps/host-manager"
    tomcat_logs: "{{ tomcat_install_dir }}/logs"
    manager_context: "{{ tomcat_manager_dir }}/META-INF/context.xml"
    host_manager_context: "{{ tomcat_host_manager_dir }}/META-INF/context.xml"

  tasks:
    # -------------------------------------------------------------------------
    - name: Ensure tomcat install dir exists
      file:
        path: "{{ tomcat_install_dir }}"
        state: directory
        owner: "{{ tomcat_user }}"
        group: "{{ tomcat_group }}"
        mode: '0755'

    # -------------------------------------------------------------------------
    # Ensure manager webapp is present (stat).
    - name: Check if manager webapp directory exists
      stat:
        path: "{{ tomcat_manager_dir }}"
      register: manager_dir_stat

    - name: Check if host-manager webapp directory exists
      stat:
        path: "{{ tomcat_host_manager_dir }}"
      register: host_manager_dir_stat

    # -------------------------------------------------------------------------
    # If manager is missing, attempt to extract it from the tarball (if available)
    # This is common when minimal distributions strip webapps.
    - name: Extract only webapps (manager & host-manager) from tarball if missing
      when: not (manager_dir_stat.stat.exists and host_manager_dir_stat.stat.exists)
      unarchive:
        src: "/tmp/tomcat.tar.gz"
        dest: "{{ tomcat_install_dir }}"
        remote_src: yes
        extra_opts: [--strip-components=1]
      register: unarchive_result
      ignore_errors: yes

    # -------------------------------------------------------------------------
    # If manager still missing after extraction, warn and list contents of webapps.
    - name: List webapps directory for debugging if manager missing
      when: not manager_dir_stat.stat.exists
      shell: "ls -la {{ tomcat_install_dir }}/webapps || true"
      register: webapps_list
      changed_when: false

    - name: Show detected webapps (debug)
      when: not manager_dir_stat.stat.exists
      debug:
        var: webapps_list.stdout_lines

    # -------------------------------------------------------------------------
    # Ensure Manager and Host Manager context.xml allow access (blockinfile)
    - name: Ensure RemoteAddrValve allows all IPs in Manager context (if file exists)
      blockinfile:
        path: "{{ manager_context }}"
        marker: "<!-- {mark} ANSIBLE MANAGED BLOCK -->"
        block: |
          <Valve className="org.apache.catalina.valves.RemoteAddrValve" allow=".*" />
      when: manager_dir_stat.stat.exists
      notify: Restart Tomcat
      ignore_errors: yes

    - name: Ensure RemoteAddrValve allows all IPs in Host-Manager context (if file exists)
      blockinfile:
        path: "{{ host_manager_context }}"
        marker: "<!-- {mark} ANSIBLE MANAGED BLOCK -->"
        block: |
          <Valve className="org.apache.catalina.valves.RemoteAddrValve" allow=".*" />
      when: host_manager_dir_stat.stat.exists
      notify: Restart Tomcat
      ignore_errors: yes

    # -------------------------------------------------------------------------
    # Ensure tomcat-users.xml is present (deploy template) so manager can be accessed.
    - name: Deploy tomcat-users.xml (ensure manager user/roles exist)
      template:
        src: "{{ tomcat_users_template_src | default('tomcat-users.xml.j2') }}"
        dest: "{{ tomcat_install_dir }}/conf/tomcat-users.xml"
        owner: root
        group: root
        mode: '0644'
      notify: Restart Tomcat

    # -------------------------------------------------------------------------
    # Fix ownership on webapps to ensure Tomcat can see manager app files
    - name: Ensure webapps owned by tomcat user
      file:
        path: "{{ tomcat_install_dir }}/webapps"
        owner: "{{ tomcat_user }}"
        group: "{{ tomcat_group }}"
        recurse: yes
      when: manager_dir_stat.stat.exists or host_manager_dir_stat.stat.exists
      ignore_errors: yes

    # -------------------------------------------------------------------------
    # Start Tomcat non-blocking (keeps same behavior you had)
    - name: Start Tomcat (non-blocking) as tomcat user
      become_user: "{{ tomcat_user }}"
      shell: "nohup {{ tomcat_install_dir }}/bin/startup.sh >/dev/null 2>&1 &"
      args:
        executable: /bin/bash
      register: tomcat_start
      changed_when: "'no change' not in tomcat_start.stdout"
      ignore_errors: yes

    # -------------------------------------------------------------------------
    # Wait for port 8080
    - name: Wait for Tomcat to listen on 8080 (remote host)
      wait_for:
        host: 127.0.0.1
        port: 8080
        state: started
        timeout: 60
      delegate_to: "{{ inventory_hostname }}"
      ignore_errors: yes

    # -------------------------------------------------------------------------
    # Check the /manager/html endpoint (this may return 401 if auth required)
    - name: Check /manager/html is present (returns 401 or 200 when app is deployed)
      uri:
        url: "http://{{ ansible_host | default(inventory_hostname) }}:8080/manager/html"
        method: GET
        status_code: [200,401]
        return_content: no
        timeout: 5
      register: manager_status
      failed_when: false
      retries: 6
      delay: 5
      until: manager_status.status in [200,401]

    # -------------------------------------------------------------------------
    # If we still get 404, gather last lines of catalina.out and list webapps for debugging
    - name: Gather catalina.out last 200 lines if /manager/html returned 404
      when: manager_status.status == 404
      shell: "tail -n 200 {{ tomcat_logs }}/catalina.out || true"
      register: catalina_tail
      changed_when: false
      ignore_errors: yes

    - name: Show catalina logs for debugging (if 404)
      when: manager_status.status == 404
      debug:
        var: catalina_tail.stdout_lines

    - name: List webapps directory if /manager/html returned 404
      when: manager_status.status == 404
      shell: "ls -la {{ tomcat_install_dir }}/webapps || true"
      register: webapps_list_after
      changed_when: false
      ignore_errors: yes

    - name: Show webapps list (if 404)
      when: manager_status.status == 404
      debug:
        var: webapps_list_after.stdout_lines

    # -------------------------------------------------------------------------
    # Fallback kill task: keep exactly as you wrote it (no changes)
    - name: Fallback - kill any lingering Tomcat bootstrap java processes
      become: yes
      shell: |
        pkill -f 'org.apache.catalina.startup.Bootstrap' || true
      args:
        warn: false
      ignore_errors: yes

  handlers:
    - name: Restart Tomcat
      become: yes
      shell: |
        {{ tomcat_install_dir }}/bin/shutdown.sh || true
        sleep 2
        {{ tomcat_install_dir }}/bin/startup.sh || true
      args:
        executable: /bin/bash
      listen: Restart Tomcat
